//__________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

void descent_parsing                 (TREE ** tree);

//___________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
//________________________________________________________________AUXILIARY_FUNCTIONS________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

void calculate_power                 (TREE ** tree)
{
    int first_number, second_number;

    first_number  = (* tree) -> left_branch  -> info . value;

    second_number = (* tree) -> right_branch -> info . value;

    (* tree) = T_number(power_number(first_number, second_number));   
}

//____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
//_________________________________________________________________SIMPLE_OPTIMIZATION________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

void optimize_plus                   (TREE ** tree)
{
    if (check_number((* tree) ->  left_branch, NULL)
    &&  check_number((* tree) -> right_branch, NULL))
    {
        CALC_NODE(PLUS,  +, * tree)
        CALC_NODE(MINUS, -, * tree)
    }
    if (check_number((* tree) -> left_branch,  &ZERO))
    {
        (* tree) = (* tree) -> right_branch;          return;
    }
    if (check_number((* tree) -> right_branch, &ZERO))
    {
        (* tree) = (* tree) -> left_branch;           return;
    }
}

//____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

void optimize_product                (TREE ** tree)
{
    if (check_number((* tree) ->  left_branch, NULL)
    &&  check_number((* tree) -> right_branch, NULL))
    {
        CALC_NODE(MULTIPLICATION, *, * tree) 

        return;
    }
    if (check_number((* tree) -> left_branch,  &ZERO)
    ||  check_number((* tree) -> right_branch, &ZERO))
    {
        (* tree) = NULL;                              return;
    }
    if (check_number((* tree) -> left_branch,   &ONE))
    {
        (* tree) = (* tree) -> right_branch;          return;
    }
    if (check_number((* tree) -> right_branch,  &ONE))
    {
        (* tree) = (* tree) -> left_branch;           return;
    }
}

//____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

void optimize_division               (TREE ** tree)
{
    if (compare_tree((* tree) -> left_branch, (* tree) -> right_branch))

        (* tree) =  T_number(ONE);
}

//____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

void optimize_degree                 (TREE ** tree)
{
    if (check_number((* tree) ->  left_branch, NULL)
    &&  check_number((* tree) -> right_branch, NULL))
    {
        calculate_power(tree); 

        return;
    }
    if (check_number((* tree) -> right_branch,  &ONE))
    {
        (* tree) = (* tree) -> left_branch;           return;
    }
    if (check_number((* tree) -> right_branch, &ZERO))
    {
        (* tree) =  T_number(ONE);                    return; 
    }
}

//____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

void optimization                    (TREE ** tree)
{
        if (!check_null((* tree) ->  left_branch)) 

            optimization(&((* tree) -> left_branch));
        
        if (!check_null((* tree) -> right_branch)) 

            optimization(&((* tree) -> right_branch));

        if (check_symbol((* tree),  PLUS)
        ||  check_symbol((* tree), MINUS))

                {optimize_plus    (tree); return;}

        if (check_symbol((* tree), MULTIPLICATION))

                {optimize_product (tree); return;}

        if (check_symbol((* tree), DIVISION))

                {optimize_division(tree); return;}

        if (check_symbol((* tree), DEGREE))

                {optimize_degree  (tree); return;}
}

//____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
//___________________________________________________________________CONSTANT_CONDENSER_______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

int product_constant_condenser       (TREE ** tree)
{
    int constant_box;

    if (check_symbol((* tree), MULTIPLICATION))
    {
        return (product_constant_condenser(&((* tree) -> left_branch)) *
        
        product_constant_condenser(&((* tree) -> right_branch)));
    }
    if (check_number((* tree), NULL))
    {
        constant_box = (* tree) -> info . value;

        (* tree) = T_number(ONE);

        return constant_box;
    }
    else return ONE; 
}

//____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

int addition_constant_condenser      (TREE ** tree)
{
    int box = ZERO;

    if (check_symbol((* tree),  PLUS) == true
    ||  check_symbol((* tree), MINUS) == true)
    {
        return (addition_constant_condenser(&((* tree) -> left_branch)) +
        
        addition_constant_condenser(&((* tree) -> right_branch)));
    }
    if (check_number((* tree), NULL) == true)
    {
        if (check_symbol((* tree) -> mother, MINUS) == true

        &&  compare_tree((* tree), (* tree) -> mother -> right_branch) == ZERO)

             box = - ((* tree) -> info . value);

        else box = (* tree) -> info . value;

        (* tree) = T_number(ZERO);

        return box;
    }
    else return ZERO; 
}

//____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
//___________________________________________________________________CONDENSING_PRODUCT_______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

int seak_product_similarities        (TREE ** tree, TREE * box)      //ТУТ ГДЕ-ТО ГОВНО                                                 //finds similarities with the BOX in the tree of the whole product
{
    if (check_symbol((* tree), MULTIPLICATION))
    {
        return 

        (seak_product_similarities(&((* tree) ->  left_branch), box) +
               
         seak_product_similarities(&((* tree) -> right_branch), box));
    }
    if (compare_tree((* tree), box))
    {
        (* tree) = T_number(ONE);

        return ONE;
    }
    else return ZERO;
}

//____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

void seak_product_element            (TREE ** tree, TREE * copy)                                  //finds an element of the tree copy to find similarities
{
    if (check_symbol(copy, MULTIPLICATION))
    {
        seak_product_element(tree, copy ->  left_branch);
        seak_product_element(tree, copy -> right_branch);

        return;
    }
    TREE * box  = tree_copy(copy); 

    int counter = seak_product_similarities(tree, box); 

    box         = T_operator(DEGREE, box, T_number(counter));

    (* tree)    = T_operator(MULTIPLICATION, tree_copy(box), (* tree));
}

//____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

void product_condenser_auxiliary     (TREE ** tree)
{
    int box = product_constant_condenser(tree); 

    optimization(tree);

    TREE * copy = tree_copy(* tree);
        
    seak_product_element(tree, copy);

    (* tree) = T_operator(MULTIPLICATION, T_number(box), (* tree));

    optimization(tree);
}

//____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

void product_condenser             (TREE ** tree)                                                      //runs down the tree to find a product
{
    if (!check_null((* tree) -> left_branch))

        product_condenser(&((* tree) ->  left_branch));

    if (!check_null((* tree) -> right_branch))

        product_condenser(&((* tree) -> right_branch));
       
    if (!check_symbol((* tree)          , MULTIPLICATION)
    &&   check_symbol((* tree) -> mother, MULTIPLICATION))

        product_condenser_auxiliary(tree);
}

//____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
//___________________________________________________________________CONDENSING_ADDITION______________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

//____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
//___________________________________________________________________BRACE_OPENING_AND_PARSING________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

bool parse                            (struct TREE ** tree, struct TREE * first, struct TREE * second)                                                                       
{
    if (check_symbol(second,  PLUS)                                                
    ||  check_symbol(second, MINUS))                                             
    {    
        struct TREE * copy_left  = tree_copy(second ->  left_branch);              
        struct TREE * copy_right = tree_copy(second -> right_branch);              
                                    
        substitute (tree, T_operator(second -> info . symbol, NULL, NULL));                                                  
        
        (* tree) ->  left_branch = T_operator(MULTIPLICATION, copy_left,  tree_copy(first));               
        (* tree) -> right_branch = T_operator(MULTIPLICATION, copy_right, tree_copy(first));      
                                                                                                        
        descent_parsing(&((* tree) ->  left_branch));                                            
        descent_parsing(&((* tree) -> right_branch)); 
        
        return  true;                                          
    }
    else return false;
}

//____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

void descent_parsing                 (struct TREE ** tree)                                                       
{
    if (parse(tree, (* tree) -> left_branch, (* tree) -> right_branch))

        return;

    if (parse(tree, (* tree) -> right_branch, (* tree) -> left_branch))

        return;
}

//____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

void recursive_parsing               (struct TREE ** tree)                                                        
{
    if (!check_null((* tree) -> left_branch))                                       

        recursive_parsing(&((* tree) ->  left_branch));
        
    if (!check_null((* tree) -> right_branch)) 

        recursive_parsing(&((* tree) -> right_branch));

    if (check_symbol((* tree), MULTIPLICATION))

        descent_parsing(tree);
}

//____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
//____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

void full_optimization               (struct TREE ** tree)
{
    mother_fill(* tree);

    recursive_parsing (tree);                   infix_print(* tree);

    printf("\n");product_condenser(tree);       infix_print(* tree);printf("\n");
}

//____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________
//____________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________________

// оптимизация деления и общая функция сравнения


